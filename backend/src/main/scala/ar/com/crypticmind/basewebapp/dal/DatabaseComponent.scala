package ar.com.crypticmind.basewebapp.dal

import com.googlecode.mapperdao._
import ar.com.crypticmind.basewebapp.model._
import ar.com.crypticmind.basewebapp.core.SettingsComponent
import com.mchange.v2.c3p0.ComboPooledDataSource
import com.googlecode.mapperdao.utils.Setup
import scala.reflect.runtime.universe
import com.googlecode.mapperdao.utils.Database.DriverConfiguration
import org.joda.time.DateTime
import scala.util._
import javax.sql.DataSource

trait DatabaseComponent { this: SettingsComponent ⇒

  def createDataSource: DataSource = new ComboPooledDataSource

  object database {

    import DatabaseComponent._

    object DbVersionEntity extends Entity[String, NaturalStringId, DbVersion]("db_version") {
      val version = key("version") to (_.version.toString)
      val logDate = column("log_date") to (_.date)
      val logMessage = column("log_message") to (_.message)
      def constructor(implicit m: ValuesMap) = new DbVersion(Version(version), logDate, logMessage) with Stored
    }

    object UserEntity extends Entity[Long, SurrogateLongAndNaturalLongId, User]("tusers") {
      val id = key("id") autogenerated (_.id)
      val username = column("username") to (_.username)
      def constructor(implicit m: ValuesMap) = new User(id, username) with Stored
    }

    val dataSource = createDataSource

    val runtimeMirror = universe.runtimeMirror(this.getClass.getClassLoader)

    val module = runtimeMirror.staticModule(settings.dbDialect)
    val driverConfiguration = runtimeMirror.reflectModule(module)
    val driver = driverConfiguration.instance.asInstanceOf[DriverConfiguration]

    val (_, mapperDao, queryDao, txManager) = Setup.apply(driver, dataSource, List(UserEntity, DbVersionEntity))

    private var _cachedCurrentVersion: Option[Option[DbVersion]] = None

    def currentVersion: Option[DbVersion] = _cachedCurrentVersion match {
      case Some(Some(cachedVersion)) ⇒ Some(cachedVersion)
      case _ ⇒
        val freshCurrentVersion =
          queryDao.lowLevelQuery( // mapperdao doesn't support aggregate functions yet
            DbVersionEntity,
            "SELECT * FROM db_version dbv WHERE dbv.log_date = SELECT max(log_date) FROM db_version",
            Nil).headOption
        _cachedCurrentVersion = Some(freshCurrentVersion)
        freshCurrentVersion
    }

    def invalidateCachedCurrentVersion() {
      _cachedCurrentVersion = None
    }

    def checkDatabaseVersion() = Try(currentVersion) match {
      case Success(Some(dbVersion)) if dbVersion.version == settings.dbRequiredVersion ⇒
      // Yay!
      case Success(Some(otherDbVersion)) ⇒
        throw new IllegalStateException(s"Database version mismatch: Expected ${settings.dbRequiredVersion}, actual ${otherDbVersion.version}")
      case Success(None) ⇒
        throw new IllegalStateException("Database is not setup (could not determine database version)")
      case Failure(exception) ⇒
        throw new IllegalStateException("Database is not setup (error occurred)", exception)
    }

  }

}

object DatabaseComponent {

  case class Version(major: Int, minor: Int, revision: Int) extends Ordered[Version] {
    override def toString = s"$major.$minor.$revision"
    def compare(that: Version) = {
      val majorC = major.compareTo(that.major)
      val minorC = minor.compareTo(that.minor)
      val revisionC = revision.compareTo(that.revision)
      if (majorC != 0) majorC else if (minorC != 0) minorC else revisionC
    }
  }
  object Version {
    val zero = Version(0, 0, 0)
    def apply(versionString: String): Version = versionString split "\\." match {
      case Array(major, minor, revision) ⇒ Version(major.toInt, minor.toInt, revision.toInt)
      case Array(major, minor)           ⇒ Version(major.toInt, minor.toInt, 0)
      case Array(major)                  ⇒ Version(major.toInt, 0, 0)
      case x                             ⇒ throw new IllegalArgumentException(s"Unrecognized version value $x")
    }
  }

  case class DbVersion(version: Version, date: DateTime, message: String)
  object DbVersion {
    def apply(version: String, date: DateTime, message: String): DbVersion = DbVersion(Version(version), date, message)
  }

}
